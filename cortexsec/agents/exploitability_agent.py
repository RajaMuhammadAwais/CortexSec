from cortexsec.core.agent import BaseAgent, PentestContext


class ExploitabilityAgent(BaseAgent):
    """
    Non-destructive exploitability/impact reasoning for reachable findings.
    """

    def __init__(self, llm):
        super().__init__("ExploitabilityAgent", llm)

    def run(self, context: PentestContext) -> PentestContext:
        self.log("Evaluating real-world impact and exploitability for reachable findings...")

        analyzed = 0
        reachable = 0
        confidence_values = []
        high_priority = []

        for finding in context.findings:
            if not finding.reachable:
                continue

            reachable += 1
            severity = finding.severity.lower()
            cvss = float(finding.cvss_score or 0.0)

            if severity in {"critical", "high"} or cvss >= 7.0:
                exploitability = "Likely exploitable in real environments if preconditions are met."
                impact = "Can create significant business impact (data exposure/account compromise/service disruption)."
                exp_conf = 0.9
                # 2026 Logic: API keys and endpoints are higher risk
                if "api" in finding.title.lower() or "key" in finding.title.lower():
                     exploitability += " (High-value API target)"
                     exp_conf = 0.95

            elif severity == "medium" or cvss >= 4.0:
                exploitability = "Moderately exploitable when configuration and access conditions align."
                impact = "Can increase lateral movement or privilege misuse risk."
                exp_conf = 0.75
            else:
                exploitability = "Lower exploitability in isolation, but can support chained attacks."
                impact = "Lower standalone impact, relevant for defense-in-depth."
                exp_conf = 0.6
                
            # 2026 Logic: Chained attacks increase exploitability of lower severity items
            if getattr(finding, "chained_to", None):
                exploitability += " (Part of an attack chain)"
                exp_conf = min(exp_conf + 0.1, 1.0)

            finding.exploitability_summary = exploitability
            finding.impact_summary = impact
            finding.exploitability_confidence = exp_conf
            finding.analyzed = True
            analyzed += 1
            confidence_values.append(exp_conf)

            if severity in {"critical", "high"}:
                high_priority.append(finding.title)

        avg_exp_conf = round(sum(confidence_values) / len(confidence_values), 3) if confidence_values else 0.0
        min_exp_conf = min(confidence_values) if confidence_values else 0.0

        context.exploitability_assessment = {
            "reachable_findings": reachable,
            "analyzed_findings": analyzed,
            "analysis_ratio": round((analyzed / reachable), 3) if reachable else 1.0,
            "avg_exploitability_confidence": avg_exp_conf,
            "min_exploitability_confidence": min_exp_conf,
            "high_priority_findings": high_priority,
            "confirmed_paths": int(context.attack_graph.get("confirmed_paths", 0)),
            "method": "Non-destructive causal exploitability reasoning",
        }

        context.history.append(
            {
                "agent": self.name,
                "message": "Exploitability and impact analysis completed",
                "analyzed": analyzed,
                "reachable": reachable,
                "avg_exploitability_confidence": avg_exp_conf,
            }
        )
        self.log(f"Exploitability analysis complete for {analyzed}/{reachable} reachable findings.")
        return context
